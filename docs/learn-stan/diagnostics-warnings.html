<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How to Diagnose and Resolve Convergence Problems – Stan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../img/logo_tm.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../theming/quarto_styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../img/logo_tm.png" alt="Stan logo" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Stan</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../install/"> 
<span class="menu-text">Getting Started</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://mc-stan.org/docs"> 
<span class="menu-text">Documentation</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-learning-resources" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Learning Resources</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-learning-resources">    
        <li>
    <a class="dropdown-item" href="../learn-stan/tutorials.html">
 <span class="dropdown-text">Tutorials</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../learn-stan/case-studies.html">
 <span class="dropdown-text">Case Studies</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../learn-stan/stancon-talks.html">
 <span class="dropdown-text">StanCon Talks</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../learn-stan/field-guides.html">
 <span class="dropdown-text">Domain-specific</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../learn-stan/publications.html">
 <span class="dropdown-text">Publications</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../learn-stan/diagnostics-warnings.html">
 <span class="dropdown-text">Diagnostics and Warnings</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../tools/"> 
<span class="menu-text">Tools</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about/"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools tools-wide">
    <a href="https://github.com/stan-dev" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
    <a href="https://discourse.mc-stan.org" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-chat-text-fill"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#when-can-warnings-be-ignored" id="toc-when-can-warnings-be-ignored" class="nav-link active" data-scroll-target="#when-can-warnings-be-ignored">When can warnings be ignored</a></li>
  <li><a href="#types-of-warnings" id="toc-types-of-warnings" class="nav-link" data-scroll-target="#types-of-warnings">Types of warnings</a>
  <ul class="collapse">
  <li><a href="#divergent-transitions-after-warmup" id="toc-divergent-transitions-after-warmup" class="nav-link" data-scroll-target="#divergent-transitions-after-warmup">Divergent transitions after warmup</a></li>
  <li><a href="#exceptions-thrown-when-hamiltonian-proposal-rejected" id="toc-exceptions-thrown-when-hamiltonian-proposal-rejected" class="nav-link" data-scroll-target="#exceptions-thrown-when-hamiltonian-proposal-rejected">Exceptions thrown when Hamiltonian proposal rejected</a></li>
  <li><a href="#r-hat" id="toc-r-hat" class="nav-link" data-scroll-target="#r-hat">R-hat</a></li>
  <li><a href="#bulk-and-tail-ess" id="toc-bulk-and-tail-ess" class="nav-link" data-scroll-target="#bulk-and-tail-ess">Bulk and Tail ESS</a></li>
  <li><a href="#maximum-treedepth" id="toc-maximum-treedepth" class="nav-link" data-scroll-target="#maximum-treedepth">Maximum treedepth</a></li>
  <li><a href="#bfmi-low" id="toc-bfmi-low" class="nav-link" data-scroll-target="#bfmi-low">BFMI low</a></li>
  </ul></li>
  <li><a href="#diagnosing-and-resolving-problems" id="toc-diagnosing-and-resolving-problems" class="nav-link" data-scroll-target="#diagnosing-and-resolving-problems">Diagnosing and resolving problems</a></li>
  <li><a href="#i-got-no-warnings-when-fitting-the-same-model-in-jagswinbugs" id="toc-i-got-no-warnings-when-fitting-the-same-model-in-jagswinbugs" class="nav-link" data-scroll-target="#i-got-no-warnings-when-fitting-the-same-model-in-jagswinbugs">I got no warnings when fitting the same model in JAGS/WinBUGS/…</a></li>
  <li><a href="#getting-help" id="toc-getting-help" class="nav-link" data-scroll-target="#getting-help">Getting help</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">How to Diagnose and Resolve Convergence Problems</h1>
</div>



<div class="quarto-title-meta column-page-left">

    
  
    
  </div>
  


</header>


<p>A big advantage of Stan is that it employs a range of diagnostics to let you notice many potential problems with your model — Stan is conservative and throws warnings for anything suspicious. Here we walk through the types of warnings and hints to help you diagnose and resolve underlying modelling problems. If you fail to diagnose/resolve the problems with the model yourself or if you have trouble understanding or applying some of the hints, don’t worry, you are welcome to ask on <a href="https://discourse.mc-stan.org/">Stan Discourse</a>, we’ll try to help!</p>
<p>For guidance on warnings that occur when compiling the model, see <a href="https://mc-stan.org/docs/stan-users-guide/understanding-stanc3-errors-and-warnings.html">Stan User’s guide on errors and warnings</a>.</p>
<section id="when-can-warnings-be-ignored" class="level2">
<h2 class="anchored" data-anchor-id="when-can-warnings-be-ignored">When can warnings be ignored</h2>
<p>In most cases the warnings actually indicate important problems with your model. This does not mean that <em>every</em> time you see a warning the model estimates are meaningless, but when you see warnings you shouldn’t trust your estimates without first understanding what the warnings mean.</p>
<p>However, in early stages of a modelling workflow, we often don’t need completely reliable inference, and a roughly correct posterior can be enough to let us check if the model is sensible using posterior predictive checks. If warnings occur rarely or the diagnostics are just somewhat above the recommended threshold, it often makes sense to do some rough sanity checks before investigating the warnings in detail. This can help to avoid investing a lot of time debugging a model that would be discarded anyway due to lack of fit to data or other conceptual problems.</p>
</section>
<section id="types-of-warnings" class="level2">
<h2 class="anchored" data-anchor-id="types-of-warnings">Types of warnings</h2>
<ul>
<li>Divergent transitions after warmup</li>
<li>Exceptions thrown when computing target density and its gradient (Hamiltonian proposal rejected)</li>
<li>R-hat</li>
<li>Bulk- and Tail-ESS</li>
<li>Maximum treedepth</li>
<li>BFMI low</li>
</ul>
<section id="divergent-transitions-after-warmup" class="level3">
<h3 class="anchored" data-anchor-id="divergent-transitions-after-warmup">Divergent transitions after warmup</h3>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="sc">:</span> There were <span class="dv">15</span> divergent transitions after warmup.</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Stan uses Hamiltonian Monte Carlo (HMC) to explore the target distribution — the posterior defined by a Stan program + data — by simulating the evolution of a <a href="https://en.wikipedia.org/wiki/Hamiltonian_system">Hamiltonian system</a>. In order to approximate the exact solution of the Hamiltonian dynamics we need to choose a step size governing how far we move each time we evolve the system forward. <em>The step size controls the resolution of the sampler</em>.</p>
<p>For hard problems the curvature of the posterior can vary a lot and there can be features of the target distribution that are too small for this resolution. For example, divergences are likely if the log posterior density doesn’t have continuous derivative everywhere. Consequently the sampler misses those features and returns biased estimates. Fortunately, this mismatch of scales manifests as <em>divergences</em> which provide a practical diagnostic.</p>
<p>Even a small number of divergences after warmup cannot be safely ignored if completely reliable inference is desired. But if you get only few divergences and you get good Rhat and ESS values, the resulting posterior is often good enough to move forward. There are also cases when a small number divergences without any pattern in their locations can be verified to be unimportant, but this cannot be safely assumed without a careful investigation of the model.</p>
<p><strong>Further reading on divergences:</strong></p>
<ul>
<li><a href="https://betanalpha.github.io/assets/case_studies/identifiability.html">Identity Crisis</a> - a discussion of the causes of divergences, diagnosis and treatment.</li>
<li><a href="https://www.martinmodrak.cz/2018/02/19/taming-divergences-in-stan-models/">Taming divergences in Stan models</a> a less mathematical but hopefully more accessible intuition on what divergent transitions are.</li>
<li><a href="https://arxiv.org/abs/1701.02434">A Conceptual Introduction to Hamiltonian Monte Carlo</a></li>
</ul>
</section>
<section id="exceptions-thrown-when-hamiltonian-proposal-rejected" class="level3">
<h3 class="anchored" data-anchor-id="exceptions-thrown-when-hamiltonian-proposal-rejected">Exceptions thrown when Hamiltonian proposal rejected</h3>
<p><strong>Examples:</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Exception thrown at line <span class="dv">24</span><span class="sc">:</span> normal_log<span class="sc">:</span> Scale parameter is <span class="dv">0</span>, but must be positive<span class="sc">!</span> </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="sc">-----</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>Rejecting initial value<span class="sc">:</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>Gradient evaluated at the initial value is not finite.</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>Stan can’t start sampling from this initial value.</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The first warning indicates that the standard deviation (scale parameter) of the normal distribution (at line 24 in the Stan program) is 0, but it must be positive for Stan to compute the value of density function.</p>
<p>The second message indicates that the gradient of the target (as computed by Stan’s automatic differention) is infinite, indicating numerical problems somewhere in the model but unfortunately without clear information about where exactly.</p>
<p>There are many other types of these warnings. A message like this does not necessarily indicate that something is wrong with your model, as it’s possible that even in a correctly specified and generally well-behaved model a numerical inaccuracy is occasionally seen, especially during warmup (for example, scale parameter with zero lower bound can still become numerically indistinguishable from 0). If such warnings occur only before the first iteration it is a sign that initialization is problematic. In this case changing the initial values can help but is not necessary if there are no further warnings. Warnings after the first few iterations may indicate bugs or numerical issues in the model and if exceptions occur many times, investigation is definitely warranted.</p>
<p><strong>Further reading on numerical accuracy of floating point format used in the computation:</strong> - <a href="https://stat.umn.edu/geyer/3701/notes/arithmetic.html">Lecture notes by Geyer (2020) “Stat 3701 Lecture Notes: Computer Arithmetic”</a> provide code examples in R illustrating the most common issues in floating-point arithmetic which can cause also unwanted rounding to the boundary of the constraint.</p>
</section>
<section id="r-hat" class="level3">
<h3 class="anchored" data-anchor-id="r-hat">R-hat</h3>
<p>R-hat (sometimes also Rhat) convergence diagnostic compares the between- and within-chain estimates for model parameters and other univariate quantities of interest. If chains have not mixed well (so that between- and within-chain estimates don’t agree), R-hat is larger than 1. We recommend running at least four chains by default and in general only fully trust the sample if R-hat is less than 1.01. In early workflow, R-hat below 1.1 is often sufficient.</p>
<p>Stan reports R-hat as the maximum of rank normalized split-R-hat and rank normalized folded-split-R-hat, which works for thick tailed distributions and is sensitive also to differences in scale.</p>
<p>High R-hat means that the chains have not mixed well and so there is not a good reason to think of them as them being fully representative of the posterior.</p>
<p>When there are divergent transitions in the model, high R-hat is often just another symptom of the problematic geometry that caused the divergences. If there are “maximum treedepth” warnings alongside high R-hat, it usually reflects a problematic geometry of the posterior that is hard to traverse efficiently and is often a side effect of setting very high <code>adapt_delta</code> in an attempt to resolve divergences. High R-hat without other warnings is commonly associated with posteriors that have multiple well-separated modes for the offending parameters, but can also arise in unimodal posteriors with difficult geometry, in case of high correlations, or in near improper posteriors.</p>
<p>R-hat and ESSs (see below) are useful quick summaries, but for the final results, it is useful to check also Monte Carlo standard error for the quantities of interest and compare that to the domain knowledge of the required accuracy, and if it is low, then run longer chains to get more samples from the posterior.</p>
<p><strong>Further reading on R-hat:</strong></p>
<ul>
<li><a href="https://arxiv.org/abs/1903.08008">Rank-normalization, folding, and localization: An improved <span class="math inline">\(\hat{R}\)</span> for assessing convergence of MCMC</a></li>
<li>Documentation for the <a href="https://mc-stan.org/posterior/reference/rhat.html">rhat()</a> function in the <code>posterior</code> package.</li>
</ul>
</section>
<section id="bulk-and-tail-ess" class="level3">
<h3 class="anchored" data-anchor-id="bulk-and-tail-ess">Bulk and Tail ESS</h3>
<p>Roughly speaking, the effective sample size (ESS) of a quantity of interest captures how many independent draws contain the same amount of information as the dependent sample obtained by the MCMC algorithm. The higher the ESS the better. Stan uses R-hat adjustment to use the within- and between-chain information in computing the ESS. For example, in case of multimodal distributions with well-separated modes, this leads to an ESS estimate that is close to the number of distinct modes that are found.</p>
<p>Bulk-ESS refers to the effective sample size based on the rank normalized draws. This does not directly compute the ESS relevant for computing the mean of the parameter, but instead computes a quantity that is well defined even if the chains do not have finite mean or variance. Overall bulk-ESS estimates the sampling efficiency for location summaries such as mean and median. Often smaller ESS would be sufficient for the desired estimation accuracy, but the estimation of ESS and convergence diagnostics themselves require higher ESS. For final results, we recommend requiring that the bulk-ESS is greater than 100 times the number of chains. For example, when running four chains, this corresponds to having a rank-normalized effective sample size of at least 400. In early workflow, ESS &gt; 20 is often sufficient.</p>
<p>Tail-ESS computes the minimum of the effective sample sizes (ESS) of the 5% and 95% quantiles. Tail-ESS can help diagnose problems due to different scales of the chains and slow mixing in the tails. If one or more chains has no draws below the 5% or above 95% quantiles computed from the all draws, there will be no direct way to assess that those chains are not completely failing, and thus NA (not available) can be reported for tail-ESS. &gt; [name=Paul] We recently changed this policy in posterior because constant within chain was too conservative and turned out to return NA to oft</p>
<p>In most cases, low bulk-ESS and tail-ESS is accompanied by large R-hat, and all recommendations for large Rhat are often useful in dealing with low ESS.</p>
<p>R-hat and ESS are useful quick summaries, but for final results, it can useful to check also Monte Carlo standard error for the quantities of interest and compare that to the domain knowledge of the required accuracy, and if needed then sample from the posterior.</p>
<p><strong>Further reading on ESS:</strong></p>
<ul>
<li><a href="https://arxiv.org/abs/1903.08008">Rank-normalization, folding, and localization: An improved <span class="math inline">\(\hat{R}\)</span> for assessing convergence of MCMC</a></li>
<li><a href="https://avehtari.github.io/rhat_ess/ess_comparison.html">Comparison of MCMC effective sample size estimators.</a></li>
<li>Documentation for <a href="https://mc-stan.org/posterior/reference/ess_bulk.html">ess_bulk()</a> and <a href="https://mc-stan.org/posterior/reference/ess_tail.html">ess_tail()</a> in the <code>posterior</code> package.</li>
</ul>
</section>
<section id="maximum-treedepth" class="level3">
<h3 class="anchored" data-anchor-id="maximum-treedepth">Maximum treedepth</h3>
<p>Warnings about hitting the maximum treedepth are not as serious as other warnings. While divergent transitions, high R-hat and low ESS are a <em>validity</em> concern, hitting the maximum treedepth is an <em>efficiency</em> concern. Configuring the No-U-Turn-Sampler (the variant of HMC used by Stan) involves putting a cap on the number of simulation steps it evaluates during each iteration (for details on this see the <em>Hamiltonian Monte Carlo Sampling</em> chapter in the <a href="http://mc-stan.org/documentation/">Stan manual</a>). This is controlled through a maximum tree depth parameter <code>max_treedepth</code> where the maximum number of steps is <code>2^max_treedepth</code>. When the maximum allowed tree depth is reached it indicates that NUTS might be terminating prematurely to avoid excessively long execution time.</p>
<p>If this is the only warning you are getting and your ESS and R-hat diagnostics are good, it is likely safe to ignore this warning, but finding the root cause could result in a more efficient model.</p>
<p>We do <em>not</em> generally recommend increasing max treedepth. In practice, the max treedepth limit being reached can be a sign of model misspecification, and to increase max treedepth can then result in just taking longer to fit a model that you don’t want to be fitting.</p>
</section>
<section id="bfmi-low" class="level3">
<h3 class="anchored" data-anchor-id="bfmi-low">BFMI low</h3>
<p><strong>Example:</strong></p>
<pre><code>The E-BFMI 0.2786 is below the nominal threshold of 0.3 which suggests that
HMC may have trouble exploring the target distribution.</code></pre>
<p>You may see a warning that says some number of chains had an estimated BFMI that was too low. This implies that the adaptation phase of the Markov chains did not turn out well or the posterior has thick tails that were not well explored in the simulation. As with other warnings, if the BFMI value is just slightly below the threshold, the posterior is likely good for sanity checks but probably still not good for final inferences.</p>
<p>A brief technical description of the diagnostic can be found in section 6.1 of <a href="https://arxiv.org/abs/1701.02434">A Conceptual Introduction to Hamiltonian Monte Carlo</a> and a thorough account is given in https://arxiv.org/abs/1604.00695.</p>
</section>
</section>
<section id="diagnosing-and-resolving-problems" class="level2">
<h2 class="anchored" data-anchor-id="diagnosing-and-resolving-problems">Diagnosing and resolving problems</h2>
<p>Diagnosing problems is best thought of as a part of larger workflow of model building, testing and critique/evaluation. Building blocks of such workflow are provided in our <a href="https://arxiv.org/abs/2011.01808">Bayesian Workflow</a> article.</p>
<p>Some approaches that can be helpful for most types of warnings follow. This is not, and can’t be, a definitive guide — each case is problematic in its own way and there is no single approach that would always work.</p>
<p>If you are using Stan via a package or other higher-level interface such as <code>rstanarm</code> or <code>brms</code>, your options are more limited, but the general advice below still applies. Additionally you may want to consult the package documentation or the underlying Stan code to get a good understanding on what is happening under the hood.</p>
<ol type="1">
<li><p>Reduce your model. Find the smallest / least complex model and a (preferably simulated) dataset that shows problems. Only add more complexity after you resolve or at least understand all the issues with the small model. If your model has multiple components (for example, a linear predictor for parameters in an ODE model), build and test small models where each of the components is separate (for example, a separate linear model and separate ODE model with constant parameters). For higher-level interfaces, this usually means removing predictor terms.</p>
<ul>
<li>The <a href="https://hyunjimoon.github.io/SBC/articles/small_model_workflow.html">small model implementation workflow</a> vignette from the SBC package shows an example of building a larger model from simpler components step-by-step.</li>
</ul></li>
<li><p>Reduce your data (if it is big). Diagnosing a model that takes a long time to fit and has many parameters is difficult, so working with a suitable subset of the data can speed the process up. This is however a double-edged sword as some problems can be caused by having not enough data, notably fitting varying slopes/intercepts for less than 3 categories can be problematic if priors are weak.</p>
<ul>
<li>You can often reduce the model and data at the same time - e.g.&nbsp;if your linear model has multiple predictors, you can filter the data to only contain rows with a specific value of a categorical predictor (or narrow range of a continuous predictor) and then remove the predictor from the model.</li>
</ul></li>
<li><p>Use stronger priors. Often a computation is slow to converge because it is drifting all over parameter space. A reasonable prior can control things by reducing the range of operation. Including a reasonable prior will not always solve problems of computation, but often it gets rid of the worst problems.</p></li>
<li><p>Visualisations: in R some very useful plots are provided by the <a href="https://mc-stan.org/bayesplot"><code>bayesplot</code></a> package (e.g.&nbsp;<code>mcmc_parcoord</code>, <code>mcmc_pairs</code>, <code>mcmc_rank_overlay</code>) and the <a href="https://mc-stan.org/shinystan"><code>shinystan</code></a> package (which provides an interactive GUI). In Python and Julia the <a href="https://arviz-devs.github.io/arviz/"><code>ArviZ</code></a> and <a href="https://arviz-devs.github.io/ArviZ.jl/"><code>ArviZ.jl</code></a> packages provide similar functionality. The most commonly useful visualisation is the pairs plot where well behaved models commonly show a set of “Gaussian blobs” while any other pattern can indicate problems. Further reading:</p>
<ul>
<li><a href="https://mc-stan.org/bayesplot/articles/visual-mcmc-diagnostics.html">bayesplot vignette on diagnostics</a></li>
<li><a href="https://arviz-devs.github.io/arviz/examples/index.html">ArviZ example gallery</a></li>
<li><a href="http://mc-stan.org/users/documentation/case-studies/divergences_and_bias.html">Case study - diagnosing a multilevel model</a></li>
<li>The <a href="https://hyunjimoon.github.io/SBC/articles/small_model_workflow.html">small model implementation workflow</a> vignette from the SBC package shows (among other things) how several problems manifest in a <code>pairs</code> plot.</li>
<li><a href="https://arxiv.org/pdf/1709.01449.pdf">Gabry et al.&nbsp;2019 - Visualization in Bayesian workflow</a></li>
</ul></li>
<li><p>Make sure all parameters in your model are well informed by the model. Typical problematic situations are when large changes in parameters can result in almost the same posterior density (for example complete separation in a logistic regression) and multimodality (multiple local maxima of the posterior distributions). Further reading:</p>
<ul>
<li><a href="http://mc-stan.org/users/documentation/case-studies/identifying_mixture_models.html">Case study - mixture models</a></li>
<li><a href="https://www.martinmodrak.cz/2018/05/14/identifying-non-identifiability/">Identifying non-identifiability</a> - some informal intuition of the concept and examples of problematic models and how to spot them.</li>
<li><a href="https://betanalpha.github.io/assets/case_studies/underdetermined_linear_regression.html">Underdetermined linear regression</a> discusses problems arising when the data cannot inform all parameters.</li>
<li>https://discourse.mc-stan.org/t/interpretation-of-cor-term-from-multivariate-animal-models/16703/26 has an example where a varying intercept at individual-level is not informed by the data.</li>
</ul></li>
<li><p>If computation is very slow in the warmup stage, this can sometimes be fixed by choosing more reasonable initial values rather than using Stan’s defaults, which can be so widely dispersed that for models with complex geometries, chains can get stuck in unimportant regions of parameter space.</p></li>
<li><p><strong>Specifically for divergences/max treedepth:</strong></p>
<ul>
<li>Check that the log posterior density and its derivatives are everywhere continuous. Numerical instabilities and inaccuracies can also cause the log density or its derivatives to behave discontinuously in practice, even if they are continuous in theory.</li>
<li>If the model seems “almost OK” or it is very fast to fit, you might be able to resolve the warnings by playing a bit with <code>adapt_delta</code> and <code>stepsize</code>; <a href="http://singmann.org/hierarchical-mpt-in-stan-i-dealing-with-convergent-transitions-via-control-arguments/">see here for an example</a>. Increasing <code>adapt_delta</code> in particular has become common as the go-to first thing people try, and while there are cases where it can be useful, it may also be possible to obtain more efficient sampling with the default <code>adapt_delta</code> and modified model, prior or parameterization. Increasing <code>adapt_delta</code>/<code>max_treedepth</code> will likely increase the sampling time per iteration. You are more likely to achieve both better sampling performance and a more robust model (not to mention understanding thereof) by pursing the above options and leaving adjustment of <code>adapt_delta</code> as a last-resort. Increasing <code>adapt_delta</code> beyond 0.99 and <code>max_treedepth</code> beyond 12 is seldom useful. For the purpose of diagnosis, it is sometimes helpful to have <em>more</em> divergences, so reverting to default settings for diagnosis can be useful. Increasing <code>adapt_delta</code>/<code>max_treedepth</code> is rarely useful to resolve Rhat/ESS/BFMI issues.</li>
</ul></li>
<li><p>Create a simulated dataset with known true values of all parameters. If the errors disappear on simulated data and the posterior mostly covers the “true” parameters from the simulation, your model may be a bad fit for the actual observed data. If you are using a higher-level interface, writing code to simulate data is a great way to test whether you understand what the model is actually doing. Further reading:</p>
<ul>
<li><a href="https://betanalpha.github.io/assets/case_studies/falling.html">Falling (In Love With Principled Modeling)</a> has examples of using Stan to simulate data.</li>
<li>https://discourse.mc-stan.org/t/failure-to-recover-simulated-group-means-in-cross-classified-lmm-with-monotonic-predictor/12978 shows an R simulation for a complex model and how it helped diagnose a bug.</li>
<li><code>brms</code> can simulate datasets using the <code>sample_prior = "only"</code> argument (see the <a href="https://paul-buerkner.github.io/brms/reference/brm.html">docs</a> for more details).</li>
</ul></li>
<li><p>Move parameters to the <code>data</code> block and set them to their true values (from simulated data). Then return them one by one to <code>parameters</code> block. Which parameter introduces the problems?</p></li>
<li><p>Using a simulated dataset, introduce tight priors centered at true parameter values (known from the simulation). How tight need the priors to be to let the model fit? Useful for identifying multimodality.</p></li>
<li><p>Check your code. Problems are almost as likely a result of a programming error as they are a truly statistical issue. This is most relevant for exceptions and rejections.</p>
<ul>
<li>Are all the declared parameters used in the model?</li>
<li>Do all parameters have informative priors?</li>
<li>Do your array indices and for loops match?</li>
<li>Do you have correct hard bounds (e.g.&nbsp;standard deviation parameters have <code>&lt;lower=0&gt;</code>, probabilities have <code>&lt;lower=0, upper=1&gt;</code>). Don’t use hard bounds to express soft prior knowledge as the effects to the shape of the posterior are not trivial.</li>
<li>Check for other errors/warnings in the Stan output (for example <code>Location parameter is inf, but must be finite!</code>) and investigate their sources, as they usually hint at coding errors. In <code>rstan</code>, those warnings might not get displayed unless you run with <code>chains = 1</code>.</li>
</ul></li>
<li><p><strong>Specifically for exceptions/rejections:</strong> Help the sampler avoid bounds of the parameter space and numerical inaccuracies.</p>
<ul>
<li>Use priors that place less weight on values near the boundary (if that’s consistent with domain expertise).</li>
<li>Use numerically stable expressions. This includes always performing calculations on the log-scale when possible and making use of Stan’s special composed functions. For example, <code>log_sum_exp(x)</code> is more robust numerically than <code>log(sum(exp(x))</code>. Other examples like this include <code>log1m(x)</code> instead of <code>log(1-x)</code>, <code>log1p_exp(x)</code> instead of <code>log(1 + exp(x))</code>, and many others. See the <a href="https://mc-stan.org/docs/functions-reference/composed-functions.html"><em>Composed Functions</em></a> subsection of the the Stan functions reference for a complete listing.</li>
<li>Use the <code>print()</code> function in your Stan model to display intermediate values in a computation to see where an invalid value originates.</li>
</ul></li>
<li><p>Introduce more informative priors. If your posterior includes values that imply some clearly absurd predictions (e.g.&nbsp;10m tall humans, almost zero between-subject differences in survival, …), removing those by a stricter prior might be useful.</p>
<ul>
<li>When working on the logarithmic scale (e.g.&nbsp;logistic/Poisson regression) even seemingly narrow priors like <code>normal(0, 1);</code> can be actually quite wide (this makes an odds ratio/multiplicative effect of <code>exp(2)</code> or roughly <code>7.4</code> still a-priori plausible - is that consistent with your domain expertise?).</li>
<li>Some (slightly outdated) advice on priors is at https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations</li>
<li>Half-normal or half-student distribution is usually preferable to half-cauchy for sd parameters in varying intercept/effect models. <a href="https://discourse.mc-stan.org/t/why-studentt-3-0-1-for-prior/8102">Forum discussion</a>, <a href="http://www.stat.columbia.edu/~gelman/research/published/taumain.pdf">Gelman 2006</a></li>
<li>If you have additional knowledge that would let you defensibly constrain your priors use it. <a href="https://betanalpha.github.io/assets/case_studies/identifiability.html">Identity Crisis</a> has some discussion of when this can help.</li>
<li>Simulating data from the prior (a.k.a <em>prior predictive check</em>) is a good way to check if the priors and their interaction are roughly reasonable. <a href="https://arxiv.org/abs/1709.01449">Gabry et al.&nbsp;2019</a> has an example.</li>
</ul></li>
<li><p>Compare your priors to the posterior distribution. If the model is sampling heavily in the very tails of your priors or on the boundaries of parameter constraints, this is a bad sign, indicating that your priors might be substantially influencing the sampling. Here, setting wider priors can sometimes help.</p></li>
<li><p><em>Reparametrize</em> your model. An ideal posterior is close to independent normal distributions in each parameter as those result in constant curvature. Any deviations from this ideal — sharp corners, edges, cusps, banana shapes, tight correlations or other irregularities signal potential targets for reparametrization. In default setting, Stan will automatically rescale each parameter by a constant factor during adaptation, so the absolute scale of the posterior is usually not very important. The main part of reparametrization is to change the actual parameters and compute your parameters of interest in the <code>transformed parameters</code> block. Further reading:</p>
<ul>
<li>Stan user’s guide <a href="https://mc-stan.org/docs/stan-users-guide/reparameterization-section.html">chapter on reparametrization</a>.</li>
<li><a href="http://mc-stan.org/users/documentation/case-studies/divergences_and_bias.html">Case study - diagnosing a multilevel model</a> discusses <em>non-centered parametrization</em> which is frequently useful.</li>
<li><a href="https://betanalpha.github.io/assets/case_studies/hierarchical_modeling.html">The case study on hierarchical models</a> by Mike Betancourt goes into more detail on the non-centered parametrization, <a href="https://arxiv.org/pdf/1312.0906">Betancourt &amp; Girolami 2015</a> addresses the same topic.</li>
<li><a href="https://discourse.mc-stan.org/t/uncentered-exponential-priors-and-hyperpriors/21224">Non-centered parametrization for the exponential distribution</a></li>
<li>Stan users guide chapter <a href="https://mc-stan.org/docs/stan-users-guide/QR-reparameterization-section.html">on QR reparametrization for linear models</a></li>
<li><a href="https://www.martinmodrak.cz/2018/05/14/identifying-non-identifiability/#a-weakly-identified-sigmoid-model">Identifying non-identifiability - a sigmoid model</a> shows an example of where the parameters are not well informed by data, while https://discourse.mc-stan.org/t/difficulties-with-logistic-population-growth-model/8286/3 show a potential reparametrization.</li>
<li><a href="https://www.biorxiv.org/content/10.1101/352070v1">Reparametrizing the Sigmoid Model of Gene Regulation</a> shows problems and solutions in an ODE model.<br>
</li>
<li><a href="https://discourse.mc-stan.org/t/test-soft-vs-hard-sum-to-zero-constrain-choosing-the-right-prior-for-soft-constrain/3884">Multiple parametrizations of a sum-to-zero constraint</a>.</li>
</ul></li>
<li><p><strong>Specifically for low BFMI warnings:</strong></p>
<ul>
<li>Look at the <code>pairs</code> plot to see which primitive parameters are correlated with the <code>energy__</code> margin.</li>
<li>The primitive parameters that are correlated with the <code>energy__</code> margin in the <code>pairs</code> plot are a good place to start thinking about reparameterizations. There should be be a negative relationship between <code>lp__</code> and <code>energy__</code> in the <code>pairs</code> plot, but this is not a concern because <code>lp__</code> is the logarithm of the posterior kernel rather than a primitive parameter.</li>
</ul></li>
<li><p><strong>Specifically for Rhat, ESS, low BFMI warnings:</strong> You might try setting a higher number of warmup or sampling iterations. Increasing the number of iterations is rarely helpful for resolving divergences/max treedepth warnings.</p>
<ul>
<li>Look at change in bulk-ESS and tail-ESS when the number of iterations increase. If R-hat is less than 1.01 and ESS grows linearly with the number of iterations and eventually exceeds the recommended limit, the mixing is sufficient but MCMC has high autocorrelation requiring a large number of iterations.</li>
</ul></li>
<li><p>Run the <code>optimizing</code> mode (penalized maximum likelihood) instead of sampling (NUTS) to check if the resulting values look at least roughly reasonable, if not try to find out why.</p></li>
<li><p>Run Stan in diagnose (<code>test_grad</code>) mode to test the gradient computations. This can sometimes detect numerical instabilities in your model.</p></li>
</ol>
</section>
<section id="i-got-no-warnings-when-fitting-the-same-model-in-jagswinbugs" class="level2">
<h2 class="anchored" data-anchor-id="i-got-no-warnings-when-fitting-the-same-model-in-jagswinbugs">I got no warnings when fitting the same model in JAGS/WinBUGS/…</h2>
<p>You might not be used to seeing so many warnings from other software you use, but that <em>does not mean</em> that Stan has more problems than that other software. The Stan Development Team places a high priority on notifying users about any issue that could potentially be important and Stan will always tell you about problems it encounters instead of hiding them from you.</p>
<p>A huge advantage of the algorithms used by Stan is that they permit certain unique diagnostics that are unavailable when using other algorithms. This can lead to more warnings from Stan, but this is a <em>feature</em> rather than a drawback. Sometimes when people reimplement a model from some other software in Stan, they get unexpected warnings, and further investigation reveals that the problem is not Stan being too sensitive, but that the original model in fact did not compute the correct posterior.</p>
</section>
<section id="getting-help" class="level2">
<h2 class="anchored" data-anchor-id="getting-help">Getting help</h2>
<p>Te best place to get help from Stan developers and users if you have difficulties fitting a model is to visit the <a href="http://discourse.mc-stan.org/">Stan Forums</a>.</p>
<p>In order to both reduce the amount of help you need and allow us to give the best help when you do need it, it is recommended to: * Put Stan programs in a stand-alone file with a <code>.stan</code> extension. Even though some Stan interfaces allow specifying the model as a string, the line numbers in warning and error messages are only meaningful if you use a separate file. * Maintain reproducibility by saving the model and initial values in files and the RStan (other other Stan interface) commands in scripts. * Use version control such as git on your files and scripts so that you have a history of the changes you’ve made. * Start simple! Build your model in stages, and check for good fits at each stage, only adding complexity if there are no red flags. If you start by writing a complicated model it can be more difficult to figure out where things are going wrong.</p>


</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>